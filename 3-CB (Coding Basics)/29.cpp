// Maximize length of the String by concatenating characters from an Array of Strings

// Given an array of strings arr[], the task is to find the maximum possible length of a string of distinct characters that can be generated by concatenating of the subsequence of the given array.

// Examples:

// Input: arr[] = {“ab”, “cd”, “ab”} 
// Output: 4 
// Explanation: 
// All possible combinations are {“”, “ab”, “cd”, “abcd”, “cdab”}. 
// Therefore, maximum length possible is 4.

// Input: arr[] = {“abcdefgh”} 
// Output: 8 
// Explanation: 
// All possible combinations are: “”, “abcdefgh”. 
// Therefore, the maximum length possible is 8.


#include<iostream>
#include<cmath>
#include<vector>
#include<queue>
#include<stack>
#include<unordered_set>
using namespace std;

int solve(string* arr, int n, unordered_set<char> us, string s= "")
{
    if(n==0) return s.size();

    int ans1 = solve(arr+1, n-1, us, s);

    bool flag= true;
    string t = arr[0];
    for (int i = 0; i < t.size(); i++)
    {
        if(us.count(t[i])) {flag = false; break;}

        us.insert(t[i]);
    }

    int ans2= INT_MIN;

    if(flag)
    {
        ans2 = solve(arr+1, n-1, us, s+t);
    }

    return max(ans1, ans2);
}

int solve2(string* arr, int n, string s= "")
{
    unordered_set<char> us;
    us.clear();

    for (int i = 0; i < s.size(); i++)
    {
        if(us.count(s[i])) return 0;
        us.insert(s[i]);
    }

    if(n==0) return s.size();

    int ans1 = solve2(arr+1, n-1, s + arr[0]);
    int ans2 = solve2(arr+1, n-1, s);
    
    return max(ans1, ans2);
}

int main(){

    int n; cin>>n;
    string* arr= new string[n];

    for (int i = 0; i < n; i++)
    {
        cin>>arr[i];
    }
    unordered_set<char> us;
    cout<< solve(arr,n, us) <<endl;
    cout<< solve2(arr,n) <<endl;

    return 0;
}


// 4
// red blue orange magenta
