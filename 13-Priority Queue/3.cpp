// QUESTION: WHY DO WE NEED A PRIORITY QUEUE
// ANSWER  : WHEN WE TRY TO BOOK A FLIGHT TICKET AND ASSUMING THE FLIGHT IS FULL!!!, THEN OUR NAME  
          // IS IN THE WAITING LIST.... NOW IN THAT WAITING LIST.. SUPPOSE THERE IS A "VIP" OR AN IMPORTANT PERSON,,, THEN HE SHOULD BE GIVEN PRIORITY!!, SO IF SOMEONE WHOSE TICKET IS BOOKED DOES NOT APPEAR, THEN SOMEONE IN THE WAITING LIST GETS A TICKET!!, NOW WHO SHOULD GET THE TICKET FIRST? OFCOURSE, THE "VIP".
        //   NOW, THERES COULD BE VARIOUS LEVELS OF "IMPORTANCE", THE 'VIP' , 'VVIP', 'VVVIP' ETC.....SO WE NEED A DATA STRUCTURE WHICH CHOOSES AND BOOKS TICKETS OF PEOPLE IN ORDER OF THEIR IMPORTANCE FROM THE WAITING LIST... WE CALL IT THE "PRIORITY QUEUE"
 
// We r going to discuss which data structure is best for storing priority queue and why...
// The 3 main functions that we need are "insert", "getMin/Max", "delete"
// The time complexities of the 3 functions for the various data structures are respectively:

// Note : deleting an element from the array requires O(n) bcoz u need to move/shift all the elements 

//      INSERTION  ---- GET_MIN/MAX ----- DELETION
// Array(unsorted) : O(1), O(n), O(n)
// Array( sorted ) : O(n), O(1), O(n)
// LL   (unsorted) : O(1), O(n), O(n)
// LL   ( sorted ) : O(n), O(1), O(1)

// BST             : O(h), O(h), O(h)
// Balanced BST    : O(n*logn), O(n*logn), O(n*logn)

// So, so far, the balanced BST is the best data structure to store the priority queue...

// But there are some shortcomings in that too....so we are going to create our own data-structure, which is similar to BST




// The data-structure which we r going to use is called "HEAP"

// HEAP HAS 2 PROPERTIES : I> IT IS A COMPLETE BINARY TREE
//                       :II> IT IS ORDERED HEAP PROPERTY


// A COMPLETE BINARY TREE : IT MEANS A BINARY TREE IN WHICH EACH LEVEL IS FULLY FILLED BEFORE FILLING THE NEXT LEVEL, AND, ELEMENTS OF EACH LEVEL ARE FILLED "STRICTLY" FROM LEFT TO RIGHT!!, WHICH MEANS EVERY TIME YOU HAVE TO FILL IN A SPECIFIC SPOT!!! U CAN'T JUST FILL ANYWHERE!, THERE WILL BE ONLY ONE SPOT SATISFYING BOTH THE CRITERIAS

// HEAP ORDER PROPERTY : THERE CAN BE 2 TYPES OF HEAP, "MINIMUM HEAP" AND "MAXIMUM HEAP", IN MINIMUM-HEAP, THE LEAST/MINIMUM ELEMENT(THE ELEMENT WITH LEAST "PRIORITY-FACTOR") IS THE MOST IMPORTANT ONE, SO ITS REMOVED FIRST, AND THEN WE REMOVE 2ND SMALLEST ELEMENT AND THEN 3RD SMALLEST.
// SIMILARLY IN MAXIMUM-HEAP, THE LARGEST ELEMENT("THE ELEMENT WITH HIGHEST "PRIORITY-FACTOR") IS THE MOST IMPORTANT ONE. SO WHEN WE ARE REMOVING AN ELEMENT.... THE ELEMENT WITH MAX PRIORITY-FACTOR SHOULD BE REMOVED FIRST...(OR SHOULD BE GIVEN HIGHEST PRIORITY)       (WE MIGHT USE IT FOR "VIPS" , WHERE E.G. WHILE BOOKING A FLIGHT TICKET... THE VIPS SHOULD BE GIVEN FIRST PRIORITY.. AND THEN OTHERS... THAT'S WHY WE HAVE THESE PRIORITY QUEUES)

// NOW, FOR "MIN-HEAP",'HEAP ORDER PROPERTY' STATES THAT : IMAGINE THE COMPLETE BINARY TREE IN WHICH THE ELEMENTS ARE SUCH THAT THE ROOT HAS THE MINIMUM ELEMENT... AND ALL CHILDREN ARE ALWAYS GREATER THAN THEIR PARENTS....(BCOZ PARENTS HAVE HIGHER PRIORITY THAT IS LOWER NUMERICAL VALUE HERE)

// NOW, IF A NEW ELEMENT IS STORED, ITS STORED AT THE LAST POSITION IN THE BINARY TREE...BUT LATER ITS SHIFTED/ ITS POSITION IS INTER-CHANGED WITH  THE OTHER NODES... SUCH THAT IT REACHES THE CORRECT/ ITS RIGHTFUL NODE POSITION IN ACCORDANCE TO "HEAP-ORDER-PROPERTY".

